{
  "api/index.html": {
    "href": "api/index.html",
    "title": "Petstore API | DocFX Material",
    "keywords": "Petstore API This is a sample server Petstore server. You can find out more about Swagger at http://swagger.io or on irc.freenode.net, #swagger . For this sample, you can use the api key special-key to test the authorization filters. About Url Version Contact Terms of Service License petstore.swagger.io/v2 1.0.0 apiteam@swagger.io http://swagger.io/terms/ Apache 2.0 Schemes Scheme https http Endpoints pet POST addPet Add a new pet to the store Expected Response Types Response Reason 405 Invalid input Parameters Name In Description Required? Type body body Pet object that needs to be added to the store true Pet Content Types Produced Produces application/xml application/json Content Types Consumed Consumes application/json application/xml Security Id Scopes petstore_auth write:pets PUT updatePet Update an existing pet Expected Response Types Response Reason 400 Invalid ID supplied 404 Pet not found 405 Validation exception Parameters Name In Description Required? Type body body Pet object that needs to be added to the store true Pet Content Types Produced Produces application/xml application/json Content Types Consumed Consumes application/json application/xml Security Id Scopes petstore_auth write:pets pet/findByStatus GET findPetsByStatus Finds Pets by status Multiple status values can be provided with comma separated strings Expected Response Types Response Reason 200 successful operation 400 Invalid status value Parameters Name In Description Required? Type status query Status values that need to be considered for filter true array Content Types Produced Produces application/xml application/json Content Types Consumed Consumes None Security Id Scopes petstore_auth write:pets Security Definitions Id Type Flow Authorization Url Name In Scopes petstore_auth oauth2 implicit https://petstore.swagger.io/oauth/authorize :write:pets, :read:pets api_key apiKey api_key header Scope Description modify pets in your account write:pets read your pets Definitions ApiResponse Definition Property Type Format code integer int32 type string message string Category Definition Property Type Format id integer int64 name string Property Type Format id integer int64 petId integer int64 quantity integer int32 shipDate string date-time status string complete boolean Pet Definition Property Type Format id int64 category integer name Category photoUrls string tags array status array Tag Definition Property Type Format id integer int64 name string User Definition Property Type Format id integer int64 username string firstName string lastName string email string password string phone string userStatus integer int32 Additional Resources Find out more about Swagger"
  },
  "articles/standard/back-end/bestPractice.html": {
    "href": "articles/standard/back-end/bestPractice.html",
    "title": "Data Base | DocFX Material",
    "keywords": "Data Base Table Prefix Database tables should have a prefix associated per module in the application. For example: SYS for system, WKF for workflow. After each prefix should have an underscore \"_\". Use CODE prefix for lookup tables and CONF prefix for configuration tables. Table Name After prefix is used the table name should be named using Pascal Case, were the first letter of each word is CAPITLIZED. For example: PEI_WorkflowStep. Field Name Each table field name should be named using Pascal Case, were the first letter of each word is CAPITLIZED. For example: PEI_Student.FirstName. Fields Required and Order Each table must contain the following required fields: CreatedBy, CreatedDate, UpdatedBy, Updated Date and IsDeleted. The order established for the table fields is: Primary Key ID Foreign Keys ID Other Fields Required Fields (CreatedBy, CreatedDate, etc.) References The following references were used in the creation of this Coding Standards Guide. Encodo c Handbook http://archive.msdn.microsoft.com/encodocsharphandbook/Release/ProjectReleases.aspx?ReleaseId=3352 CSharp Coding Standards http://weblogs.asp.net/lhunt/pages/CSharp-Coding-Standards-document.aspx Microsoft All-In-One Code Framework Coding Guideline http://1code.codeplex.com/wikipage?title=All-In-One%20Code%20Framework%20Coding%20Standards&referringTitle=Documentation c / VB.Net Coding Guidelines http://submain.com/blog/FreeCVBNETCodingGuidelinesEbookDownload.aspx Top 10 Best Practices for Production ASP.NET Applications http://daptivate.com/archive/2008/02/12/top-10-best-practices-for-production-asp-net-applications.aspx Best Practices to Improve ASP.Net Web Application Performance http://www.dotnetfunda.com/articles/article45.aspx ASP.NET Best Practices for High Performance Applications http://www.codeproject.com/KB/aspnet/ASPNET_Best_Practices.aspx"
  },
  "articles/standard/back-end/formatting.html": {
    "href": "articles/standard/back-end/formatting.html",
    "title": "Indent and spacing | DocFX Material",
    "keywords": "Indent and spacing An indent is four (4) spaces. Use a single space after a comma (e.g. between function arguments). There is no space after the leading parenthesis/bracket or before the closing parenthesis/bracket. There is no space between a method name and the leading parenthesis, but there is a space before the leading parenthesis of a flow control statement. Use a single space to surround all 2 infix operators (e.g. firstValue ?? secondvalue : thirdValue); there is no space between a prefix operator (e.g. \"-\" or \"!\") and its argument. Do not use spacing to align type members on the same column (e.g. as with the members of an enumerated type). Braces Curly braces should—with a few exceptions outlined below—go on their own line. A line with only a closing brace should never be preceded by an empty line. A line with only an opening brace should never be followed by an empty line. Return Statements If a return statement is not the only statement in a method, it should be separated from other code by a single newline (or a line with only a bracket on it). if (a == 1) { return true; } return false; Caution if (a == 1) { return true; } //**Do not** use else with return statements (use the style shown above instead): else// Not necessary { return false; } Switch Statements Contents under switch statements should be indented. Braces for a case-label are not indented; this maintains a nice alignment with the brackets from the switch-statement. Use braces for longer code blocks under case-labels; leave a blank line above the break statement to improve clarity. switch (flavor) { case Flavor.Up: case Flavor.Down: { if (someConditionHolds) { // Do some work } // Do some more work break; } default: break; } Empty Lines In the following list, the phrase \"surrounding code\" refers to a line consisting of more than just an opening or closing brace. That is, no new line is required when an element is at the beginning or end of a methods or other block-level element. Always place an empty line in the following places: Between the file header and the namespace declaration or the first using statement. Between the last using statement and the namespace declaration. Between types (classes, structs, interfaces, delegates or enums). Between public, protected and internal members. Between a call to a base method and ensuing code. Between return statements and surrounding code (this does not apply to return statements at the beginning or end of methods). Between block constructs (e.g. while loops or switch statements) and surrounding code. Between documented enum values; undocumented may be grouped together. Between logical groups of code in a method; this notion is subjective and more a matter of style. You should use empty lines to improve readability, but should not overuse them. Between the last line of code in a block and a comment for the next block of code. Between statements that are broken up into multiple lines. Between a #region tag and the first line of code in that region. Between the last line of code in a region and the #endregion tag. Caution Do not place an empty line in the following places: After another empty line; the AFCG style uses only single empty lines. Between retrieval code and handling for that code. Instead, they should be formatted together. IMetaReadableObject obj = context.Find\\&lt;IMetaReadableObject\\&gt;(); if (obj == null) { context.Recorder.Log(Level.Fatal, String.Format(&quot;Error!&quot;)); return null; } Between any line and a line that has only an opening or closing brace on it (i.e. there should be no leading or trailing newlines in a block). Between undocumented fields (usually private); if there are many such fields, you may use empty lines to group them by purpose. Line Breaking Caution Do not put more than one statement on a single line because it makes stepping through the code in a debugger much more difficult. No line should exceed 100 characters; use the line-breaking rules listed below to break up a line. Use line-breaking only when necessary; do not adopt it as standard practice. If one or more line-breaks is required, use as few as possible. Line-breaking should occur at natural boundaries; the most common such boundary is between parameters in a method call or definition. Lines after such a line-break at such a boundary should be indented. The separator (e.g. a comma) between elements formatted onto multiple lines goes on the same line after the element; the IDE is much more helpful when formatting that way. The most natural line-breaking boundary is often before and after a list of elements. For example, the following method call has line-breaks at the beginning and end of the parameter list. people.DataSource = CurrentCompany.Employees.GetList( connection, metaClass, GetFilter(), null ); If one of the parameters is much longer, then you add line-breaking between the parameters; in that case, all parameters are formatted onto their own lines: connection, metaClass, GetFilter(&quot;Global.Applications.Updater.PersonList.Search&quot;), null ); Note in the examples above that the parameters are indented. If the assignment or method call was longer, they would no longer fit on the same line. In that case, you should use two levels of indenting. Avoid nesting more than two ternary operators in a single line. Break it down into a series of if/else statements. // Bad! bool result = condition1 ? true : contition2 ? true : condition3 ? true : false; // Good! if(condition1) { result = true; } elseif(condition2) { result = true; } elseif(condition3) { result = true; } else { result = false; } Code Commenting All comments should be written in the same language, be grammatically correct, and contain appropriate punctuation. Use // or /// but never /* … */ Do not \"flowerbox\" comment blocks. // *************************************** // Comment block // *************************************** Use inline-comments to explain assumptions, known issues, and algorithm insights. In-line comments are the Post-It notes of programming. This is where you make annotations to help yourself or another programmer who needs to work with the code later. Use In-line comments to make notes in your code about: What you are doing. Where you are up to. Why you have chosen a particular option. Any external factors that need to be known. Here are some examples of appropriate uses of In-line comments: What we are doing: // Now update the control totals file to keep everything in sync Where we are up to: // At this point, everything has been validated. // If anything was invalid, we would have exited the procedure. Why we chose a particular option: // Use a sequential search for now because it's simple to code // We can replace with a binary search later if it's not fast // enough // We are using a file-based approach rather than doing it all // in memory because testing showed that the latter approach // used too many resources under Win2000. That's why the code // is here rather than in XXX.VB where it belongs. External factors that need to be kept in mind: // This assumes that the INI file settings have been checked by // the calling routine Do not use inline-comments to explain obvious code. Well written code is self-documenting. Notice that we are not documenting what is self-evident from the code. Here are some examples of inappropriate In-line comments: // Declare local variables int currentEmployee; // Increment the array index currentEmployee += 1; // Call the update routine UpdateRecord(); Include comments using Task-List keyword flags to allow comment-filtering. // TODO: Place Database Code Here // TODO: Removed P\\Invoke Call due to errors Always apply c comment-blocks (///) to public, protected, and internal Only use c comment-blocks for documenting the API. Always include &lt;summary&gt; Include &lt;param&gt;, &lt;return&gt;, and &lt;exception&gt;comment sections where applicable. Include &lt;see cref=\"\"/&gt;and &lt;seeAlso cref=\"\"/&gt;where possible. Always add CDATA tags to comments containing code and other embedded markup in order to avoid encoding issues. Example: /// &lt;example&gt; /// Add the following key to the \"appSettings\" section of your config: /// &lt;code&gt;&lt;![CDATA[ /// &lt;configuration&gt; /// &lt;appSettings&gt; /// &lt;add key=\"mySetting\" value=\"myValue\"/&gt; /// &lt;/appSettings&gt; /// &lt;/configuration&gt; /// ]]&gt;&lt;/code&gt; /// &lt;/example&gt; Comments example of a class: /// &lt;summary&gt; /// Applications workflow item object class. /// &lt;/summary&gt; /// &lt;author&gt; /// A.G. Rosario /// &lt;/author&gt; /// &lt;remarks&gt; /// Provide the functionality to manage the workflow process of an a item record from the database. /// &lt;/remarks&gt; public class WorkflowItem { … } Do not ** leave commented code.** Every code is in a repository so it can be consulted anytime in the future."
  },
  "articles/standard/back-end/languageUsage.html": {
    "href": "articles/standard/back-end/languageUsage.html",
    "title": "Declaration Order | DocFX Material",
    "keywords": "Declaration Order Note Group internal class implementation by type in the following order: Nested Enums, Structs, and Classes Member variables Properties Constructors & Finalizers Methods Sequence declarations within type groups based upon access modifier and visibility: Public Protected Internal Private Segregate interface Implementation by using #region statements"
  },
  "articles/standard/back-end/naming.html": {
    "href": "articles/standard/back-end/naming.html",
    "title": "Naming Guidelines | DocFX Material",
    "keywords": "Naming Guidelines Of all the components that make up a coding standard, naming standards are the most visible and arguably the most important. Having a consistent standard for naming the various objects in your program will save you an enormous amount of time both during the development process itself and also during any later maintenance work. General Rules Names are in US-English (e.g. use \"color\" instead of \"colour\"). Names conform to English grammatical conventions (e.g. use ImportableDatabase instead of DatabaseImportable). Names should be as short as possible without losing meaning. Prefer whole words or stick to predefined short forms or abbreviations of words. Make sure to capitalize compound words correctly; if the word is not hyphenated, then it does not need a capital letter in the camel- or Pascal-cased form. For > example, \"metadata\" is written as Metadata in Pascal-case, not MetaData. Acronyms should be Pascal-case as well (e.g. \"Xml\" or \"Sql\") unless they are only two letters long. Acronyms at the beginning of a camel-case identifier are always all lowercase (more info see Abbreviations). Identifiers differing only by case may be defined within the same scope only if they identify different language elements (e.g. a local variable and a property). Capitalization Styles Use the following convention for capitalizing identifiers in Back End. Pascal Case The first letter in the identifier and the first letter of each subsequent concatenated word are capitalized. You can use Pascal case for identifiers of three or more characters. For example: B ack C olor Camel Case The first letter of an identifier is lowercase and the first letter of each subsequent concatenated word is capitalized. For example: b ack C olor Upper Case All letters in the identifier are capitalized. Use this convention only for identifiers that consist of two or fewer letters. For example: System.IO System.Web.IO You might also have to capitalize identifiers to maintain compatibility with existing, unmanaged symbol schemes, where all uppercase characters are often used for enumerations and constant values. In general, these symbols should not be visible outside of the assembly that uses them. The following table summarizes the capitalization rules and provides examples for the different types of identifiers: Identifier Case Example Class Pascal AppDomain Enum type Pascal ErrorLevel Enum values Pascal FatalError Event Pascal ValueChange Exception class Pascal WebException Note: Always ends with the suffix Exception. Read-only Static field Pascal RedValue Interface Pascal IDisposable Note: Interfaces always begin with the prefix I. Method Pascal ToString Namespace Pascal System.Drawing Parameter Camel typeName Property Pascal BackColor Private instance field \"_\" + Camel _redValueThe underscore breaks ambiguity between a private instance field and its public access property in internal class code. Protected instance field Camel redValue Note: Rarely used. A property is preferable to using a protected instance field. Public instance field Pascal RedValue Note: Rarely used. A property is preferable to using a public instance field. Case Sensitivity To avoid confusion and guarantee cross-language interoperation, follow these rules regarding the use of case sensitivity: Do not use names that require case sensitivity. Components must be fully usable from both case-sensitive and case-insensitive languages. Case-insensitive languages cannot distinguish between two names within the same context that differ only by case. Therefore, you must avoid this situation in the components or classes that you create. Do not create two namespaces with names that differ only by case. For example, a case insensitive language cannot distinguish between the following two namespace declarations. namespace MyLibrary{} namespace Mylibrary{} Do not create a function with parameter names that differ only by case. The following example is incorrect. void MyFunction(string a, string A); Do not create a namespace with type names that differ only by case. In the following example, Point p and POINT p are inappropriate type names because they differ only by case. System.Windows.Forms.Point p; System.Windows.Forms.POINT p; Do not create a type with property names that differ only by case. In the following example, int Color and int COLOR are inappropriate property names because they differ only by case. int Color {get; set;} int COLOR {get; set;} Do not create a type with method names that differ only by case. In the following example, calculate and Calculate are inappropriate method names because they differ only by case void calculate(); void Calculate(); Note Namespaces Do not use the global namespace; the only exception is for ASP.NET pages that are generated into the global namespace. Avoid fully-qualified type names; use the using statement instead. If the IDE inserts a fully-qualified type name in your code, you should fix it. If the unadorned name conflicts with other already-included namespaces, make an alias for the class with a using clause. Avoid putting a using statement inside a namespace (unless you must do so to resolve a conflict). Avoid deep namespace-hierarchies (five or more levels) as that makes it difficult to browse and understand. Do not reference unnecessary libraries, include unnecessary header files, or reference unnecessary assemblies. Paying attention to small things like this can improve build times, minimize chances for mistakes, and give readers a good impression Never declare more than 1 namespace per file. Avoid making too many namespaces; instead, use catch-all namespace suffixes, like \"Utilities\", \"Core\" or \"General\" until it is clearer whether a class or group of classes warrant their own namespace. Refactoring is your friend here. Do not include the version number in a namespace name. Use long-lived identifiers in a namespace name. Namespaces should be plural, as they will contain multiple types (e.g. DevTeam.Expressions instead of DevTeam.Expression). If your framework or application encompasses more than one tier, use the same namespace identifiers for similar tasks. For example, common data-access code goes in DevTeam.Data. Avoid using \"reserved\" namespace names like System because these will conflict with standard .NET namespaces and require resolution using the global::namespace prefix. Fallere antiquam thyrso visceribus Si mandate videt Lorem markdownum perspice caelestia orsa tamen rorant titulum Amycus parens deplangitur fuit est ; duxit cura est. Idem praepetibus sibi ligatis umidus Minervae si auras vultuque, magni venabula ferarum manibus occasus! Note This is a note which needs your attention, but it's not super important. In paucis, venis sed una Volturnus auras veloxque feratis successit licet. Oras Nestor hoc nymphae belua. Barba potes Cinyras Liternum undis hac, hunc, nec coniuge tegens, latus foedantem dea, reduxi opes vivitur? Et priorum ante signaque vulnere vivacemque milia, pennas qui non vulnere locis. Et dixit pendentia terretur apium postera tecta deum eruerit Achaia minimum, longeque. Warning This is a warning containing some important message. Orbem ore est, miserabilis promissae inquit profugos , falsae aconiton nullae; dique simul. Eris deum cepit furoris nympha. Dies iste telae cum fidelius, mihi esse est nominat quod, Anaxareten. Venit Confremuere, inplet, tibi inspiciunt iamque maesta his suis. Caution This is a warning containing some very important message. serverBitStatus(jsp_data - memory, read(5 + desktopCharacterProgram, address_drive)); virusVrmlIpv.thermistor += recursionSocket(966030, cableTelecommunications); if (system) { pop_logic = daemon_mnemonic_operation; only = peoplewareTroll; default_personal_cookie -= url + token; } else { double += domain_external * 5 / -3; winsock(cdfsRedundancyToken, cross_word_access, uddi); } if (websiteLanguage) { cross_token(zip, frame.mbr(4)); golden.backsideOsMenu += serp; whiteRestore.videoDimmOpen += mountPlain * 15; } else { spool.irc = play_suffix; cmos += 96; artUpImpact.leafWebmasterHorse = domainBrowser; } Rogavi umeris tulisse Pictas leto vix novem nitidi mentem Phoeboque, inposuere incubat thalamo: mugitibus. Busto siquid adspexerit venerit tenentibus suo habet ardet Troes . Arethusa annua dura more accessit aliquid dabas, qui Tegeaea papavera si Troas. Vota ipsa in peremi Possent anhelatos Poena quem Nutrit super eodem Donis adhaesit requiemque petit Antaeo sustinet feram Studeat occupat viro talia truncas pectine redit crimina divum illud, precesque et Minos, quidquid gratia. Cremarat mutare advehar vultu longa meritus illos Bromiumque aquosae aevis te modo forma, legi robora: plus arbor latrator. Palluit in quanta mitte miluus; amantes hominesque imago, si Ianthe, unda. Acies in vulnere secum, forte, barba fumo solet ignibus; sanguine! if (webcamSystem.modemPointClob(3) < 14) { yobibyteReimage = simplex_readme / 4 + responsive_server; } else { big(thumbnailVirtual, data_primary_lamp); } kibibyte_protector_active += nocPackBridge + white; var firewall_socket_bus = up; module_carrier += webmail_source_hardware(us, metadata, radcab - 3) - 3; cpcPartitionLink *= sessionSoa / surface * systemHacker; Nutantem spatiis, corruat memor in sed nate, auro, ora amissa fatidicus et. Manusque amore spectabat tyranni ipsa Mimasque , et tum post parvo, dedit vires et aestus et Rhoetus! Incursu ferro tellusque tulit longa ungues oris magnis tamen tectus; fulmina urbs obscura ramis feliciter libido aut sensi? Vidi oenea puppibus amanti, pro foliis, hoc est amicitiae et! Caput favorem, inimica in spinae hoc simul stantibus pependit opesque pericula avorum paene."
  },
  "articles/standard/content4.html": {
    "href": "articles/standard/content4.html",
    "title": "C# Coding Standards | DocFX Material",
    "keywords": "C# Coding Standards Introduction The coding standard will be used in conjunction with customized version of StyleCop and FxCop [ TODO ] during both development and build process. This will help ensure that the standard is followed by all developers on the team in a consistent manner. \"Any fool can write code that a computer can understand. Good programmers write code that humans understand\". Martin Fowler. Refactoring: Improving the design of existing code. Purpose The aim of this section is to define a set of C# coding standards to be used by CAPS build team to guarantee maximum legibility, reliability, re-usability and homogeneity of our code. Each section is marked Mandatory or Recommended . Mandatory sections, will be enforced during code reviews as well as tools like StyleCop and FxCop , and code will not be considered complete until it is compliant. Scope This section contains general C# coding standards which can be applied to any type of application developed in C#, based on Framework Design Guidelines . It does not pretend to be a tutorial on C#. It only includes a set of limitations and recommendations focused on clarifying the development. Tools Resharper is a great 3rd party code cleanup and style tool. StyleCop analyzes C# srouce code to enforce a set of style and consistency rules and has been integrated into many 3rd party development tools such as Resharper. FxCop is an application that analyzes managed code assemblies (code that targets the .NET Framework common language runtime) and reports information about the assemblies, such as possible design, localization, performance, and security improvements. C# Stylizer does many of the style rules automatically Highlights of Coding Standards This section is not intended to give a summary of all the coding standards that enabled by our customized StyleCop, but to give a highlight of some rules one will possibly meet in daily coding life. It also provides some recommended however not mandatory(which means not enabled in StyleCop) coding standards. File Layout (Recommended) Only one public class is allowed per file. The file name is derived from the class name. Class : Observer Filename: Observer.cs Class Definition Order (Mandatory) The class definition contains class members in the following order, from less restricted scope (public) to more restrictive (private): Nested types, e.g. classes, enum, struct, etc. Field members, e.g. member variables, const, etc. Member functions Constructors Finalizer (Do not use unless absolutely necessary) Methods (Properties, Events, Operations, Overridables, Static) Private nested types Naming (Mandatory) DO use PascalCasing for all public member, type, and namespace names consisting of multiple words. PropertyDescriptor HtmlTag IOStream NOTE : A special case is made for two-letter acronyms in which both letters are capitalized, e.g. IOStream DO use camelCasing for parameter names. propertyDescriptor htmlTag ioStream DO start with underscore for private fields private readonly Guid _userId = Guid.NewGuid(); DO start static readonly fields, constants with capitalized case private static readonly IEntityAccessor EntityAccessor = null; private const string MetadataName = \"MetadataName\"; DO NOT capitalize each word in so-called closed-form compound words . DO have \"Async\" explicitly in the Async method name to notice people how to use it properly Formatting (Mandatory) DO use spaces over tabs, and always show all spaces/tabs in IDE Tips Visual Studio > TOOLS > Options > Text Editor > C# > Tabs > Insert spaces (Tab size: 4) Visual Studio > Edit > Advanced > View White Space DO add using inside namespace declaration namespace Microsoft.Content.Build.BuildWorker.UnitTest { using System; } DO add a space when: for (var i = 0; i < 1; i++) if (a == b) Cross-platform coding Our code should supports multiple operating systems. Don't assume we only run (and develop) on Windows. Code should be sensitvie to the differences between OS's. Here are some specifics to consider. DO use Enviroment.NewLine instead of hard-coding the line break instead of \\r\\n , as Windows uses \\r\\n and OSX/Linux uses \\n . Note Be aware that thes line-endings may cause problems in code when using @\"\" text blocks with line breaks. DO Use Path.Combine() or Path.DirectorySeparatorChar to separate directories. If this is not possible (such as in scripting), use a forward slash / . Windows is more forgiving than Linux in this regard. Unit tests and functional tests Assembly naming The unit tests for the Microsoft.Foo assembly live in the Microsoft.Foo.Tests assembly. The functional tests for the Microsoft.Foo assmebly live in the Microsoft.Foo.FunctionalTests assmebly. In general there should be exactly one unit test assebmly for each product runtime assembly. In general there should be one functional test assembly per repo. Exceptions can be made for both. Unit test class naming Test class names end with Test and live in the same namespace as the class being tested. For example, the unit tests for the Microsoft.Foo.Boo class would be in a Microsoft.Foo.Boo class in the test assembly. Unit test method naming Unit test method names must be descriptive about what is being tested, under what conditions, and what the expectations are . Pascal casing and underscores can be used to improve readability. The following test names are correct: PublicApiArgumentsShouldHaveNotNullAnnotation Public_api_arguments_should_have_not_null_annotation The following test names are incorrect: Test1 Constructor FormatString GetData Unit test structure The contents of every unit test should be split into three distinct stages, optionally separated by these comments: // Arrange // Act // Assert The crucial thing here is the Act stage is exactly one statement. That one statement is nothing more than a call to the one method that you are trying to test. keeping that one statement as simple as possible is also very important. For example, this is not ideal: int result = myObj.CallSomeMethod(GetComplexParam1(), GetComplexParam2(), GetComplexParam3()); This style is not recomended because way too many things can go wrong in this one statement. All the GetComplexParamN() calls can throw for a variety of reasons unrelated to the test itself. It is thus unclear to someone running into a problem why the failure occured. The ideal pattern is to move the complex parameter building into the `Arrange section: // Arrange P1 p1 = GetComplexParam1(); P2 p2 = GetComplexParam2(); P3 p3 = GetComplexParam3(); // Act int result = myObj.CallSomeMethod(p1, p2, p3); // Assert Assert.AreEqual(1234, result); Now the only reason the line with CallSomeMethod() can fail is if the method itself blew up. Testing exception messages In general testing the specific exception message in a unit test is important. This ensures that the exact desired exception is what is being tested rather than a different exception of the same type. In order to verify the exact exception it is important to verify the message. var ex = Assert.Throws<InvalidOperationException>( () => fruitBasket.GetBananaById(1234)); Assert.Equal( \"1234\", ex.Message); Use xUnit.net's plethora of built-in assertions xUnit.net includes many kinds of assertions – please use the most appropriate one for your test. This will make the tests a lot more readable and also allow the test runner report the best possible errors (whether it's local or the CI machine). For example, these are bad: Assert.Equal(true, someBool); Assert.True(\"abc123\" == someString); Assert.True(list1.Length == list2.Length); for (int i = 0; i < list1.Length; i++) { Assert.True( String.Equals list1[i], list2[i], StringComparison.OrdinalIgnoreCase)); } These are good: Assert.True(someBool); Assert.Equal(\"abc123\", someString); // built-in collection assertions! Assert.Equal(list1, list2, StringComparer.OrdinalIgnoreCase); Parallel tests By default all unit test assemblies should run in parallel mode, which is the default. Unit tests shouldn't depend on any shared state, and so should generally be runnable in parallel. If the tests fail in parallel, the first thing to do is to figure out why; do not just disable parallel tests! For functional tests it is reasonable to disable parallel tests."
  },
  "articles/standard/front-end/content3.html": {
    "href": "articles/standard/front-end/content3.html",
    "title": "Table of Standard Control Prefixes | DocFX Material",
    "keywords": "Table of Standard Control Prefixes The following table is a list of the common types of controls you will encounter together with their prefixes: Prefix Control btn Button cb CheckBox cbl CheckBoxList ddl DropDownList fu FileUpload hf HiddenField hl HyperLink img Image ibtn ImageButton lbl Label lbtn LinkButton lb ListBox lit Literal mvw MultiView pnl Panel ph PlaceHolder rb RadioButton rbl RadioButtonList txt TextBox vw View wzd Wizard lvw ListView gvw GridView fvw FormView rpt Repeater ods ObjectDataSource valreq RequiredFieldValidator valrng RangeValidator valcom CompareValidator valrex RegularExpressionValidator valcus CustomValidator valsum ValidationSummary sm ScriptManager udp UpdatePanel up UpdateProgress"
  },
  "articles/standard/intro.html": {
    "href": "articles/standard/intro.html",
    "title": "Goals | DocFX Material",
    "keywords": "Goals The intent of this document is not to codify current practice at DevTeam as it stands at the time of writing. Instead, this guide has the following aims: To maximize readability and maintainability by prescribing a unified style. To maximize efficiency with logical, easy-to-understand and justifiable rules that balance code safety with ease-of-use. To maximize the usefulness of code-completion tools and accommodate IDE- or framework generated code. To prevent errors and bugs (especially hard-to-find ones) by minimizing complexity and applying proven design principles. To improve performance and reliability with a list of best practices. Wherever possible, however, the guidelines include a specific justification for each design choice. Unjustified guidelines must be either justified or removed . Scope This handbook mixes recommendations for programming with .NET, MVC, AngularJS, VUE Js. It includes rules for document layout (like whitespace and element placement) as well as design guidelines for elements and best practices for their use. It also assumes that you are using Microsoft Visual Studio 2017 or newer. This guide is a work-in-progress and covers only those issues that DevTeam has encountered and codifies only that which DevTeam has put into practice and with which DevTeam has experience. Therefore, some elements of style and design as well as some implicit best practices are probably not yet documented. Speak up if you think there is something missing. Fixing Problems in the Guide Unless otherwise noted, these guidelines are not ** optional , nor are they up to interpretation**. If a guideline is not sufficiently clear, recommend a clearer formulation. If you don't like a guideline, try to get it changed or removed, but don't just ignore it. Fixing Problems in Code If code is non-conforming, it should be fixed at the earliest opportunity. If the error is small and localized, you should fix it with the next check-in (noting during the code review that the change was purely stylistic and unrelated to other bug fixes). If the error is larger and/or involves renaming or moving files, you should check the change in separately in order to avoid confusion. If the problem takes too long to repair quickly, you should create an issue in the Team Foundation Server to address the problem at a later time. When Does this Guide Apply It is the intention that all code written for or by DevTeam adheres to this standard. However, there are some cases where it is impractical or impossible to apply these conventions. This document applies to all code except the following: Code changes made to existing systems not written to this standard In general, it is a good idea to make your changes conform to the surrounding code style wherever possible. You should choose to adopt this standard for major additions to existing systems or when you are adding code that you think will become part of the DevTeam code library. Code written for customers that require that their standards should be adopted DevTeam may, from time to time work with customers that have their own coding standards. Most coding standards applicable to a Microsoft development language derive at least some of their content from a Microsoft white paper that documented a set of suggested naming standards. For this reason, many coding standards are broadly compatible with each other. This document goes a little further than most in some areas; however, it is likely that these extensions will not conflict with most other coding standards. We must be absolutely clear on this point: if there is a conflict, the customer's coding standards are to apply - always."
  },
  "CHANGELOG.html": {
    "href": "CHANGELOG.html",
    "title": "Changelog | DocFX Material",
    "keywords": "Changelog Version 0.4.0 - May 19th 2020 Usability improvements and minor style changes in textboxes. Version 0.3.1 - January 13th 2020 Minor update in styles and shadows. Version 0.3.0 - December 2nd 2019 Added easy customization of header and link colors. Version 0.2.0 - February 1st 2019 Added material theme for the note|warning|caution blockquotes. Updated syntax highlight styles. Version 0.1.0 - January 31st 2019 First release of the DocFX Material theme"
  },
  "index.html": {
    "href": "index.html",
    "title": "DocFX Material | DocFX Material",
    "keywords": "DocFX Material A simple material theme for DocFX . This is an override of the default template so you need to enable both in the docfx.json . The colors were chosen using https://material.io/tools/color . Usability improvements Highlight on search box Highlight on filter box Install Download the source or the zipped file from the releases . Create a templates folder in the root of your DocFX directory. Copy the material folder to the templates folder. Update the docfx.json configuration to include the material template: { \"template\": [ \"default\", \"templates/material\" ], } Color customization You can easily customize the color of the header bar and the links by updating the following variables in the material/styles/main.css file. /* COLOR VARIABLES*/ :root { --header-bg-color: #0d47a1; --header-ft-color: #fff; --highlight-light: #5e92f3; --highlight-dark: #003c8f; --font-color: #34393e; } Markdown extras For more reference about markdown support in DocFX check the official documentation. Note This is a note which needs your attention, but it's not super important. Warning This is a warning containing some important message. Caution This is a warning containing some very important message. DocFX tips Enable search To enable search in DocFX it's not enough to set the configuration parameter to true : \"globalMetadata\": { \"_enableSearch\": \"true\" } You also have to indicate in the docfx.json the post processor that generates the index for the searches: \"postProcessors\": [\"ExtractSearchIndex\"],"
  }
}