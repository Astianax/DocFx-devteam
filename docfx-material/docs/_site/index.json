{
  "api/index.html": {
    "href": "api/index.html",
    "title": "Petstore API | CDevTeam Docs",
    "keywords": "Petstore API This is a sample server Petstore server. You can find out more about Swagger at http://swagger.io or on irc.freenode.net, #swagger . For this sample, you can use the api key special-key to test the authorization filters. About Url Version Contact Terms of Service License petstore.swagger.io/v2 1.0.0 apiteam@swagger.io http://swagger.io/terms/ Apache 2.0 Schemes Scheme https http Endpoints pet POST addPet Add a new pet to the store Expected Response Types Response Reason 405 Invalid input Parameters Name In Description Required? Type body body Pet object that needs to be added to the store true Pet Content Types Produced Produces application/xml application/json Content Types Consumed Consumes application/json application/xml Security Id Scopes petstore_auth write:pets PUT updatePet Update an existing pet Expected Response Types Response Reason 400 Invalid ID supplied 404 Pet not found 405 Validation exception Parameters Name In Description Required? Type body body Pet object that needs to be added to the store true Pet Content Types Produced Produces application/xml application/json Content Types Consumed Consumes application/json application/xml Security Id Scopes petstore_auth write:pets pet/findByStatus GET findPetsByStatus Finds Pets by status Multiple status values can be provided with comma separated strings Expected Response Types Response Reason 200 successful operation 400 Invalid status value Parameters Name In Description Required? Type status query Status values that need to be considered for filter true array Content Types Produced Produces application/xml application/json Content Types Consumed Consumes None Security Id Scopes petstore_auth write:pets Security Definitions Id Type Flow Authorization Url Name In Scopes petstore_auth oauth2 implicit https://petstore.swagger.io/oauth/authorize :write:pets, :read:pets api_key apiKey api_key header Scope Description modify pets in your account write:pets read your pets Definitions ApiResponse Definition Property Type Format code integer int32 type string message string Category Definition Property Type Format id integer int64 name string Property Type Format id integer int64 petId integer int64 quantity integer int32 shipDate string date-time status string complete boolean Pet Definition Property Type Format id int64 category integer name Category photoUrls string tags array status array Tag Definition Property Type Format id integer int64 name string User Definition Property Type Format id integer int64 username string firstName string lastName string email string password string phone string userStatus integer int32 Additional Resources Find out more about Swagger"
  },
  "articles/codeReview/codeReview.html": {
    "href": "articles/codeReview/codeReview.html",
    "title": "| CDevTeam Docs",
    "keywords": "..."
  },
  "articles/politics/politics.html": {
    "href": "articles/politics/politics.html",
    "title": "| CDevTeam Docs",
    "keywords": "..."
  },
  "articles/pullRequest/pullRequest.html": {
    "href": "articles/pullRequest/pullRequest.html",
    "title": "Commits for PR | CDevTeam Docs",
    "keywords": "Commits for PR For each Pull Request with require this forms: <!--- Provide a general summary of your changes in the Title above --> ### Description <!--- Describe your changes in detail --> <!-- Wording about task submitted: _Example:_ ** Sesión de trabajo realizado la programación necesaria para cumplir con el requerimiento asignado ejecutando la tarea Crear Metodo de consulta Parte 1--> ### Related Issue <!--- This project only accepts pull requests related to open issues --> <!--- If suggesting a new feature or change, please discuss it in an issue first --> <!--- If fixing a bug, there should be an issue describing it with steps to reproduce --> <!--- Please link to the issue here: --> ### Motivation and Context <!--- Why is this change required? What problem does it solve? --> ### How Has This Been Tested? <!--- Please describe in detail how you tested your changes. --> <!--- Include details of your testing environment, and the tests you ran to --> <!--- see how your change affects other areas of the code, etc. --> ### Screenshots (if appropriate): ### Types of changes <!--- What types of changes does your code introduce? Put an `x` in all the boxes that apply: --> - [ ] Bug fix (non-breaking change which fixes an issue) - [ ] New feature (non-breaking change which adds functionality) - [ ] Breaking change (fix or feature that would cause existing functionality to change) ### Checklist: <!--- Go over all the following points, and put an `x` in all the boxes that apply. --> <!--- If you're unsure about any of these, don't hesitate to ask. We're here to help! --> - [ ] My code follows the code style of this project ( Example: All my methods used Async (except ApiController), All my DTO and Entity inherit from this base). - [ ] My change requires a change to the documentation. - [ ] I have updated the documentation accordingly. - [ ] I have read the **CONTRIBUTING** document (https://cdevteam.netlify.app/). - [ ] I have added tests to cover my changes. - [ ] All new and existing tests passed. Result Description Sesión de trabajo realizado la programación necesaria para cumplir con el requerimiento asignado ejecutando la tarea Crear Metodo de consulta Parte 1. Related Issue User Story: #56020 Task: #56830 Motivation and Context <!--- Why is this change required? What problem does it solve? --> How Has This Been Tested? <!--- Please describe in detail how you tested your changes. --> <!--- Include details of your testing environment, and the tests you ran to --> <!--- see how your change affects other areas of the code, etc. --> Screenshots (if appropriate): Types of changes <!--- What types of changes does your code introduce? Put an `x` in all the boxes that apply: --> [ ] Bug fix (non-breaking change which fixes an issue) [ ] New feature (non-breaking change which adds functionality) [ ] Breaking change (fix or feature that would cause existing functionality to change) Checklist: <!--- Go over all the following points, and put an `x` in all the boxes that apply. --> <!--- If you're unsure about any of these, don't hesitate to ask. We're here to help! --> [ ] My code follows the code style of this project. ( Example: All my methods used Async (except ApiController), All my DTO and Entity inherit from this base). [ ] My change requires a change to the documentation. [ ] I have updated the documentation accordingly. [ ] I have read the CONTRIBUTING document ( https://cdevteam.netlify.app/ ). [ ] I have added tests to cover my changes. [ ] All new and existing tests passed."
  },
  "articles/scrum/scrumDoc.html": {
    "href": "articles/scrum/scrumDoc.html",
    "title": "| CDevTeam Docs",
    "keywords": "..."
  },
  "articles/standard/back-end/bestPractice.html": {
    "href": "articles/standard/back-end/bestPractice.html",
    "title": "Data Base | CDevTeam Docs",
    "keywords": "Data Base Table Prefix Database tables should have a prefix associated per module in the application. For example: SYS for system, WKF for workflow. After each prefix should have an underscore \"_\". Use CODE prefix for lookup tables and CONF prefix for configuration tables. Table Name After prefix is used the table name should be named using Pascal Case, were the first letter of each word is CAPITLIZED. For example: PEI_WorkflowStep. Field Name Each table field name should be named using Pascal Case, were the first letter of each word is CAPITLIZED. For example: PEI_Student.FirstName. Fields Required and Order Each table must contain the following required fields: CreatedBy, CreatedDate, UpdatedBy, Updated Date and IsDeleted. The order established for the table fields is: Primary Key ID Foreign Keys ID Other Fields Required Fields (CreatedBy, CreatedDate, etc.) References The following references were used in the creation of this Coding Standards Guide. Encodo c Handbook http://archive.msdn.microsoft.com/encodocsharphandbook/Release/ProjectReleases.aspx?ReleaseId=3352 CSharp Coding Standards http://weblogs.asp.net/lhunt/pages/CSharp-Coding-Standards-document.aspx Microsoft All-In-One Code Framework Coding Guideline http://1code.codeplex.com/wikipage?title=All-In-One%20Code%20Framework%20Coding%20Standards&referringTitle=Documentation c / VB.Net Coding Guidelines http://submain.com/blog/FreeCVBNETCodingGuidelinesEbookDownload.aspx Top 10 Best Practices for Production ASP.NET Applications http://daptivate.com/archive/2008/02/12/top-10-best-practices-for-production-asp-net-applications.aspx Best Practices to Improve ASP.Net Web Application Performance http://www.dotnetfunda.com/articles/article45.aspx ASP.NET Best Practices for High Performance Applications http://www.codeproject.com/KB/aspnet/ASPNET_Best_Practices.aspx"
  },
  "articles/standard/back-end/formatting.html": {
    "href": "articles/standard/back-end/formatting.html",
    "title": "Indent and spacing | CDevTeam Docs",
    "keywords": "Indent and spacing An indent is four (4) spaces. Use a single space after a comma (e.g. between function arguments). There is no space after the leading parenthesis/bracket or before the closing parenthesis/bracket. There is no space between a method name and the leading parenthesis, but there is a space before the leading parenthesis of a flow control statement. Use a single space to surround all 2 infix operators (e.g. firstValue ?? secondvalue : thirdValue); there is no space between a prefix operator (e.g. \"-\" or \"!\") and its argument. Do not use spacing to align type members on the same column (e.g. as with the members of an enumerated type). Braces Curly braces should—with a few exceptions outlined below—go on their own line. A line with only a closing brace should never be preceded by an empty line. A line with only an opening brace should never be followed by an empty line. Return Statements If a return statement is not the only statement in a method, it should be separated from other code by a single newline (or a line with only a bracket on it). if (a == 1) { return true; } return false; Caution if (a == 1) { return true; } //**Do not** use else with return statements (use the style shown above instead): else// Not necessary { return false; } Switch Statements Contents under switch statements should be indented. Braces for a case-label are not indented; this maintains a nice alignment with the brackets from the switch-statement. Use braces for longer code blocks under case-labels; leave a blank line above the break statement to improve clarity. switch (flavor) { case Flavor.Up: case Flavor.Down: { if (someConditionHolds) { // Do some work } // Do some more work break; } default: break; } Empty Lines In the following list, the phrase \"surrounding code\" refers to a line consisting of more than just an opening or closing brace. That is, no new line is required when an element is at the beginning or end of a methods or other block-level element. Always place an empty line in the following places: Between the file header and the namespace declaration or the first using statement. Between the last using statement and the namespace declaration. Between types (classes, structs, interfaces, delegates or enums). Between public, protected and internal members. Between a call to a base method and ensuing code. Between return statements and surrounding code (this does not apply to return statements at the beginning or end of methods). Between block constructs (e.g. while loops or switch statements) and surrounding code. Between documented enum values; undocumented may be grouped together. Between logical groups of code in a method; this notion is subjective and more a matter of style. You should use empty lines to improve readability, but should not overuse them. Between the last line of code in a block and a comment for the next block of code. Between statements that are broken up into multiple lines. Between a #region tag and the first line of code in that region. Between the last line of code in a region and the #endregion tag. Caution Do not place an empty line in the following places: After another empty line; the AFCG style uses only single empty lines. Between retrieval code and handling for that code. Instead, they should be formatted together. IMetaReadableObject obj = context.Find\\&lt;IMetaReadableObject\\&gt;(); if (obj == null) { context.Recorder.Log(Level.Fatal, String.Format(&quot;Error!&quot;)); return null; } Between any line and a line that has only an opening or closing brace on it (i.e. there should be no leading or trailing newlines in a block). Between undocumented fields (usually private); if there are many such fields, you may use empty lines to group them by purpose. Line Breaking Caution Do not put more than one statement on a single line because it makes stepping through the code in a debugger much more difficult. No line should exceed 100 characters; use the line-breaking rules listed below to break up a line. Use line-breaking only when necessary; do not adopt it as standard practice. If one or more line-breaks is required, use as few as possible. Line-breaking should occur at natural boundaries; the most common such boundary is between parameters in a method call or definition. Lines after such a line-break at such a boundary should be indented. The separator (e.g. a comma) between elements formatted onto multiple lines goes on the same line after the element; the IDE is much more helpful when formatting that way. The most natural line-breaking boundary is often before and after a list of elements. For example, the following method call has line-breaks at the beginning and end of the parameter list. people.DataSource = CurrentCompany.Employees.GetList( connection, metaClass, GetFilter(), null ); If one of the parameters is much longer, then you add line-breaking between the parameters; in that case, all parameters are formatted onto their own lines: connection, metaClass, GetFilter(&quot;Global.Applications.Updater.PersonList.Search&quot;), null ); Note in the examples above that the parameters are indented. If the assignment or method call was longer, they would no longer fit on the same line. In that case, you should use two levels of indenting. Avoid nesting more than two ternary operators in a single line. Break it down into a series of if/else statements. // Bad! bool result = condition1 ? true : contition2 ? true : condition3 ? true : false; // Good! if(condition1) { result = true; } elseif(condition2) { result = true; } elseif(condition3) { result = true; } else { result = false; } Code Commenting All comments should be written in the same language, be grammatically correct, and contain appropriate punctuation. Use // or /// but never /* … */ Do not \"flowerbox\" comment blocks. // *************************************** // Comment block // *************************************** Use inline-comments to explain assumptions, known issues, and algorithm insights. In-line comments are the Post-It notes of programming. This is where you make annotations to help yourself or another programmer who needs to work with the code later. Use In-line comments to make notes in your code about: What you are doing. Where you are up to. Why you have chosen a particular option. Any external factors that need to be known. Here are some examples of appropriate uses of In-line comments: What we are doing: // Now update the control totals file to keep everything in sync Where we are up to: // At this point, everything has been validated. // If anything was invalid, we would have exited the procedure. Why we chose a particular option: // Use a sequential search for now because it's simple to code // We can replace with a binary search later if it's not fast // enough // We are using a file-based approach rather than doing it all // in memory because testing showed that the latter approach // used too many resources under Win2000. That's why the code // is here rather than in XXX.VB where it belongs. External factors that need to be kept in mind: // This assumes that the INI file settings have been checked by // the calling routine Do not use inline-comments to explain obvious code. Well written code is self-documenting. Notice that we are not documenting what is self-evident from the code. Here are some examples of inappropriate In-line comments: // Declare local variables int currentEmployee; // Increment the array index currentEmployee += 1; // Call the update routine UpdateRecord(); Include comments using Task-List keyword flags to allow comment-filtering. // TODO: Place Database Code Here // TODO: Removed P\\Invoke Call due to errors Always apply c comment-blocks (///) to public, protected, and internal Only use c comment-blocks for documenting the API. Always include &lt;summary&gt; Include &lt;param&gt;, &lt;return&gt;, and &lt;exception&gt;comment sections where applicable. Include &lt;see cref=\"\"/&gt;and &lt;seeAlso cref=\"\"/&gt;where possible. Always add CDATA tags to comments containing code and other embedded markup in order to avoid encoding issues. Example: /// &lt;example&gt; /// Add the following key to the \"appSettings\" section of your config: /// &lt;code&gt;&lt;![CDATA[ /// &lt;configuration&gt; /// &lt;appSettings&gt; /// &lt;add key=\"mySetting\" value=\"myValue\"/&gt; /// &lt;/appSettings&gt; /// &lt;/configuration&gt; /// ]]&gt;&lt;/code&gt; /// &lt;/example&gt; Comments example of a class: /// &lt;summary&gt; /// Applications workflow item object class. /// &lt;/summary&gt; /// &lt;author&gt; /// A.G. Rosario /// &lt;/author&gt; /// &lt;remarks&gt; /// Provide the functionality to manage the workflow process of an a item record from the database. /// &lt;/remarks&gt; public class WorkflowItem { … } Do not ** leave commented code.** Every code is in a repository so it can be consulted anytime in the future."
  },
  "articles/standard/back-end/languageUsage.html": {
    "href": "articles/standard/back-end/languageUsage.html",
    "title": "Declaration Order | CDevTeam Docs",
    "keywords": "Declaration Order Note Group internal class implementation by type in the following order: Nested Enums, Structs, and Classes Member variables Properties Constructors & Finalizers Methods Sequence declarations within type groups based upon access modifier and visibility: Public Protected Internal Private Segregate interface Implementation by using #region statements Visibility The visibility modifier is required for all types, methods and fields; this makes the intention explicit and consistent. The visibility keyword is always the first modifier. The const or readonly keyword, if present, comes immediately after the visibility modifier. The static keyword, if present, comes after the visibility modifier and readonly modifier. private readonly static string DefaultDatabaseName = \"admin\"; Constants Declare all constants other than 0 , 1 , true , false and null . Use true and false only for assignment, never for comparison. Avoid passing true or false for parameters; use an enum or constants to impart meaning instead. If there is a logical connection between two constants, indicate this by making the initialization of one dependent on the other. public const int DefaultCacheSize = 25; public const int DefaultGranularity = DefaultCacheSize / 5; Readonly vs Const The difference between const and readonly is that const is compiled and readonly is initialized at runtime. Use const only when the value really is constant (e.g. NumberDaysInWeek ); otherwise, use readonly . Though readonly for references only prevents writing of the reference, not the attached value, it is still a helpful hint for both the compiler and the reader. String and Resources Do not hardcode strings that will be presented to the user; use resources instead. For products in development, this text extraction can be performed after the code has crystallized somewhat. Resource identifiers should be alphanumeric, but may also include a dot (\".\") to logically nest resources. It should contain the name of the control sample \"lblName\", \"lblLastName\", etc. Do not use constants for strings; use resource tables instead (this aids translation, if necessary). Configuration data should be moved into application settings as soon as possible. Properties Prefer automatic properties as it saves a lot of typing and vastly improves readability. public bool ShowTab { get; set; } If there a exceptional need to manage the internal value of public property then you can create private properties. Use read-only properties if there is no logical reason for calling code to be able to change the value. Properties should be commutative; that is, it should not matter in which order you set them. Avoid enforcing an ordering by using a method to execute code that you would want to execute from the property setter. The following example is incorrect because setting the password before setting the name causes a login failure. class SecuritySystem { public string UserName { get; set; } public int Password { get; set { LogIn(); } protected void LogIn() { IPrincipal principal = Authenticate(UserName, Password); } private IPrincipal Authenticate(string UserName,int Password) { // Authenticate the user } } Instead, you should take the call LogIn() out of the setter for Password and make the method public, so the class can be used like this instead: SecuritySystem system = new SecuritySystem(); system.Password = \"knockknock\"; system.UserName = \"Encode\"; system.LogIn(); In this case, Password can be set before the UserName without causing any problems. Methods / Functions Methods should not have more than 200 lines of code. Avoid returning null for methods that return collections or strings. Instead, return an empty collection (declare a static empty list) or an empty string (Empty). Overloads are encouraged for methods that are in the same family and either serve the same purpose or have similar behavior. Do not use the types of parameters to distinguish these functions from one another. For example, the following is incorrect void Update(); void UpdateUsingQuery(IQuery query); void UpdateUsingSql(string sql); Instead, use an overload, letting the method signature describe the different functions. This reduces the perceived size of the API and makes it easier to understand. void Update(); void Update(IQuery query); void Update(string sql); Parameters Methods should not have more than 10 parameters (consider using a struct instead). Methods should not have more than 2 out or ref parameters (consider using a struct instead). ref and out parameters should come last in the list of parameters. The implementation of an interface method should use the same parameter name as that given in the interface method declaration. Do not declare reserved parameters (use overloads in future library versions instead). Classes Never declare more than one field per line; each field should be an individually documentable entity. Do not use public or protected fields; use private fields exposed through properties instead. Do not create too many static classes; instead, determine whether new functionality can be added to an existing static class. Interfaces Use interfaces to \"fake\" multiple-inheritance. Define interfaces if there will be more than one implementation of a hierarchy; without multiple-inheritance, this is the only way to remain flexible as to the implementation. Define interfaces to clearly define what comprises an API; an interface will generally be smaller and more tightly-defined that the class that implements it. A class-based hierarchy runs the risk of mixing interface methods with implementation methods. Consider using a c attribute instead of a marker interface (an interface with no members). This makes for a cleaner inheritance representation and indicates the use of the marker better (e.g. NUnit tests as well as the serializing subsystem for .NET use attributes instead of marker interfaces). Re-use interfaces as much as possible to avoid having many very similar interfaces that cause confusion as to which one should be used where. Keep interfaces relatively small in order to ease implementation (5-10 members). Where possible, provide an abstract class or default descendent that application code can use for implementing an interface. This provides both an implementation example and some protection from future changes to the interface. Use interfaces where the functionality isn't the direct purpose of the object or to expose a part of the class's functionality (as with aspect-oriented programming). Use explicit interface implementation where appropriate to avoid expanding a class API unnecessarily. Each interface should be used at least once in non-testing code; otherwise, get rid of it. Always provide at least one, tested implementation of an interface. Structs Consider defining a structure instead of a class if most of the following conditions apply: Instances of the type are small (16 bytes or less) and commonly short-lived. The type is commonly embedded in other types. The type logically represents a single value and is similar to a primitive type, like an int or a double . The type is immutable. The type will not be boxed frequently. Use the following rules when defining a struct : Avoid methods; at most, have only one or two methods other than overrides and operator overloads. Provide parameterized constructors for initialization. In scenarios that require a significant amount of boxing and un-boxing, value types perform poorly as compared to reference types. Overload operators and equality as expected; implement IEquatable instead of overriding Equals in order to avoid the negative performance impact of boxing and un-boxing the value. A struct should be valid when uninitialized so that consumers can declare an instance without calling a constructor. Public fields are allowed (even encouraged) for structures used to communicate with external APIs through unmanaged code. Enumerations Always use enumerations for strongly-typed sets of values Use enumerations instead of lists of static constants unless that list can be extended by descendent code; if the list is not logically open-ended, use an enum . Enumerations are like interfaces; be extremely careful of changing them when they are already included in code that is not under your control (e.g. used by a framework that is, in turn, used by external application code). If the enumeration must be changed, use the ObsoleteAttribute to mark members that are no longer in use. Do not assign a type to an enum unless absolutely necessary; use the default type of Int32 whenever possible. Do not include sentinel values, such as FirstValue or LastValue . Do not assign explicit values to simple enumerations except to enforce specific values for storage in a database. The first value in an enumeration is the default; make sure that the most appropriate simple enumeration value is listed first. Local variables Declare a local variable as close as possible to its first use (and within the most appropriate scope). If a local variable is initialized, put the initialization on the same line as the declaration. If the line gets too long, use multiple lines as described before in this guide. Event Handlers You should use the pattern and support classes for event-handling provided by the .NET library. Do not expose delegates as public members; instead declare events using the event keyword. Do not add a method to a delegate with new EventHandler(…) ; instead, use delegate inference. Do not define custom delegates for event handling; instead use EventHandler<T> . Put all extra event data into an EventArgs descendent; subsequent versions can alter this descendent without changing the signature. Use CancelEventArgs as the base class if you need to be able to cancel an event. Neither the sender parameter nor the args parameter may be null; this avoids forcing event handlers to check for null. EventsArgs descendents should declare only properties, not methods or other application logic. Operators Be extremely careful when overloading operators; in general, you should only do so for structs . If you feel that an operator overload is especially clever, it probably isn't; check with another developer before coding it. Avoid overriding the == operator for reference types; override the Equals() method instead to avoid redefining reference equality. If you do override Equals() , you should also override GetHashCode() . If you do override the == operator, consider overriding the other comparison operators (=, <, <=, >, >=) as well. You should return false from the Equals() function if the objects cannot be compared. However, if they are different types, you may throw an exception. If Statements Do not compare to true or false ; instead, compare pure Boolean expressions. Initialize Boolean values with simple expressions rather than using an if-statement; always use parentheses to delineate the assigned expression. bool needsUpdate = (Count > 0 && Objects[0].Modified); Always use brackets for flow-control blocks (switch, if, while, for, etc.) Do not add useless else blocks. An \"if\" statement may stand alone and an \"else if\" statement may be the last condition. if (a == b) { // Do something } else if (a > b) { // Do something else } // No final \"else\" required Do not force really complicated logic into an \"if\" statement; instead, use local variables to make the intent clearer. For example, imagine we have a lesson planner and want to find all unsaved lessons that are either unscheduled or are scheduled within a given time-frame. The following condition is too long and complicated to interpret quickly: if (!lesson.Stored && (((StartTime <= lesson.StartTime) && (lesson.EndTime >= EndTime)) || !lesson.Scheduled)) { // Do something with the lesson } Even trying to apply the line-breaking rules results in an unreadable mess: if (!lesson.Stored && (((StartTime <= lesson.StartTime) && (lesson.EndTime >= EndTime)) || !lesson.Scheduled)) { // Do something with the lesson } Even with this valiant effort, the intent of the ||-operator is difficult to discern. With local variables, however, the logic is much clearer: bool lessonInTimeSpan = ((StartTime <= lesson.StartTime) && (lesson.EndTime >= EndTime)); if (!lesson.Stored && (lessonInTimeSpan || ! lesson.Scheduled)) { >// Do something with the lesson } Using \"var\" The use of var is permitted ONLY when the explicit-type is not known or unavailable . The use of var can be used only when you need to: Use the type of ObjectQuery Use code that changes the type at runtime instead of compiletime. Is VERY IMPORTANT to comment the code with the specifications of this code. The use of var is only allowed when: The explicit-type is not known (anonymous). var car = new { Year = 2020, Model = \"Mustang GT\", Manufacturer = \"Ford\" }; Working with LINQ queries. var query = from c in DataContext where c.Id = 123 select new Car { Year = c.Year, Model = c.Model, Manufacturer = c.Model }; Initializing the variable directly with an object constructor call . var car = new Car(); Readability needs to be improved. //Bad List<ThisIsMyLongCustomCarTypeObject> data = CarTypeObjectEngine.GetAvailableModelByManufacturerId(1); // Good var data = CarTypeObjectEngine.GetAvailableModelByManufacturerId(1); Note: If the developer wants to know the type inside the \"var\" just move the cursor to the variable name. The use of var is NOT allowed when: Initializing value types or string . var index = 0; var name = \"John Doe\"; Flow Control Avoid invoking methods within a conditional expression. Avoid creating recursive methods. Use loops or nested loops instead. Avoid using foreachto iterate over immutable value-type collections. E.g. String arrays. Do not modify enumerated items within a foreach Use the ternary conditional operator only for trivial conditions. Avoid complex or compound ternary operations. int result = isValid ? 9 : 4; Avoid evaluating Boolean conditions against truer false. //Example: // Bad! if (isValid == true) {...} // Good! if (isValid) {...} Avoid assignment within conditional statements. //Example: if((i=2) == 2) {...} Avoid compound conditional expressions – use Boolean variables to split parts into multiple manageable expressions. //Example: // Bad! if (((value > _highScore) && (value != _highScore)) && (value < _maxScore)) {...} // Good! isHighScore = (value >= _highScore); isTiedHigh = (value == _highScore); isValid = (value < _maxValue); if ((isHighScore && !isTiedHigh) && isValid) {...} Avoid explicit Boolean tests in conditionals. //Example: // Bad! if(IsValid == true) {...} // Good! if(IsValid) {...} Only use switch/casestatements for simple operations with parallel conditional logic. Prefer nested if/elsever switch/casefor short conditional sequences and complex conditions. Prefer polymorphism over switch/caseto encapsulate and delegate complex operations. Exceptions Do not use try/catch blocks for flow-control. Only catch exceptions that you can handle. Never declare an empty catch. Avoid nesting a try/catch within a catch. Always catch the most derived exception via exception filters. Order exception filters from most to least derived exception type. Avoid re-throwing an exception. Allow it to bubble-up instead. If re-throwing an exception, preserve the original call stack by omitting the exception argument from the throw //Example: // Bad! catch(Exception ex) { Log(ex); throw ex; } // Good! catch(Exception) { Log(ex); throw; } Only use the finallyblock to release resources from a try Always use validation to avoid exceptions. //Example: // Bad! try { conn.Close(); } Catch(Exception ex) { // handle exception if already closed! } // Good! if(conn.State != ConnectionState.Closed) { conn.Close(); } Always set the innerExceptionproperty on thrown exceptions so the exception chain & call stack are maintained. Avoid defining custom exception classes. Use existing exception classes instead. When a custom exception is required; Always derive from Exception not ApplicationException. Always suffix exception class names with the word \"Exception\". Always add the SerializableAttributeto exception classes. Always implement the standard \"Exception Constructor Pattern\": //Example: public MyCustomException (); public MyCustomException (string message); public MyCustomException (string message, Exception innerException); Always implement the deserialization constructor: protected MyCustomException(SerializationInfo info, StreamingContext contxt); Always set the appropriate HResultvalue on custom exception classes. ( Note: the ApplicationExceptionHResult = -2146232832) When defining custom exception classes that contain additional properties: Always override the Messageproperty, ToString()method and the implicit operator string to include custom property values. Always modify the deserialization constructor to retrieve custom property values. Always override the GetObjectData(…)method to add custom properties to the serialization collection. //Example: public override void GetObjectData(SerializationInfo info, StreamingContext context) { base.GetObjectData (info, context); info.AddValue(\"MyValue\", _myValue); }"
  },
  "articles/standard/back-end/naming.html": {
    "href": "articles/standard/back-end/naming.html",
    "title": "Naming Guidelines | CDevTeam Docs",
    "keywords": "Naming Guidelines Of all the components that make up a coding standard, naming standards are the most visible and arguably the most important. Having a consistent standard for naming the various objects in your program will save you an enormous amount of time both during the development process itself and also during any later maintenance work. General Rules Names are in US-English (e.g. use \"color\" instead of \"colour\"). Names conform to English grammatical conventions (e.g. use ImportableDatabase instead of DatabaseImportable). Names should be as short as possible without losing meaning. Prefer whole words or stick to predefined short forms or abbreviations of words. Make sure to capitalize compound words correctly; if the word is not hyphenated, then it does not need a capital letter in the camel- or Pascal-cased form. For > example, \"metadata\" is written as Metadata in Pascal-case, not MetaData. Acronyms should be Pascal-case as well (e.g. \"Xml\" or \"Sql\") unless they are only two letters long. Acronyms at the beginning of a camel-case identifier are always all lowercase (more info see Abbreviations). Identifiers differing only by case may be defined within the same scope only if they identify different language elements (e.g. a local variable and a property). Capitalization Styles Use the following convention for capitalizing identifiers in Back End. Pascal Case The first letter in the identifier and the first letter of each subsequent concatenated word are capitalized. You can use Pascal case for identifiers of three or more characters. For example: B ack C olor Camel Case The first letter of an identifier is lowercase and the first letter of each subsequent concatenated word is capitalized. For example: b ack C olor Upper Case All letters in the identifier are capitalized. Use this convention only for identifiers that consist of two or fewer letters. For example: System.IO System.Web.IO You might also have to capitalize identifiers to maintain compatibility with existing, unmanaged symbol schemes, where all uppercase characters are often used for enumerations and constant values. In general, these symbols should not be visible outside of the assembly that uses them. The following table summarizes the capitalization rules and provides examples for the different types of identifiers: Identifier Case Example Class Pascal AppDomain Enum type Pascal ErrorLevel Enum values Pascal FatalError Event Pascal ValueChange Exception class Pascal WebException Note: Always ends with the suffix Exception. Read-only Static field Pascal RedValue Interface Pascal IDisposable Note: Interfaces always begin with the prefix I. Method Pascal ToString Namespace Pascal System.Drawing Parameter Camel typeName Property Pascal BackColor Private instance field \"_\" + Camel _redValueThe underscore breaks ambiguity between a private instance field and its public access property in internal class code. Protected instance field Camel redValue Note: Rarely used. A property is preferable to using a protected instance field. Public instance field Pascal RedValue Note: Rarely used. A property is preferable to using a public instance field. Case Sensitivity To avoid confusion and guarantee cross-language interoperation, follow these rules regarding the use of case sensitivity: Do not use names that require case sensitivity. Components must be fully usable from both case-sensitive and case-insensitive languages. Case-insensitive languages cannot distinguish between two names within the same context that differ only by case. Therefore, you must avoid this situation in the components or classes that you create. Do not create two namespaces with names that differ only by case. For example, a case insensitive language cannot distinguish between the following two namespace declarations. namespace MyLibrary{} namespace Mylibrary{} Do not create a function with parameter names that differ only by case. The following example is incorrect. void MyFunction(string a, string A); Do not create a namespace with type names that differ only by case. In the following example, Point p and POINT p are inappropriate type names because they differ only by case. System.Windows.Forms.Point p; System.Windows.Forms.POINT p; Do not create a type with property names that differ only by case. In the following example, int Color and int COLOR are inappropriate property names because they differ only by case. int Color {get; set;} int COLOR {get; set;} Do not create a type with method names that differ only by case. In the following example, calculate and Calculate are inappropriate method names because they differ only by case void calculate(); void Calculate(); Note Namespaces Do not use the global namespace; the only exception is for ASP.NET pages that are generated into the global namespace. Avoid fully-qualified type names; use the using statement instead. If the IDE inserts a fully-qualified type name in your code, you should fix it. If the unadorned name conflicts with other already-included namespaces, make an alias for the class with a using clause. Avoid putting a using statement inside a namespace (unless you must do so to resolve a conflict). Avoid deep namespace-hierarchies (five or more levels) as that makes it difficult to browse and understand. Do not reference unnecessary libraries, include unnecessary header files, or reference unnecessary assemblies. Paying attention to small things like this can improve build times, minimize chances for mistakes, and give readers a good impression Never declare more than 1 namespace per file. Avoid making too many namespaces; instead, use catch-all namespace suffixes, like \"Utilities\", \"Core\" or \"General\" until it is clearer whether a class or group of classes warrant their own namespace. Refactoring is your friend here. Do not include the version number in a namespace name. Use long-lived identifiers in a namespace name. Namespaces should be plural, as they will contain multiple types (e.g. DevTeam.Expressions instead of DevTeam.Expression). If your framework or application encompasses more than one tier, use the same namespace identifiers for similar tasks. For example, common data-access code goes in DevTeam.Data. Avoid using \"reserved\" namespace names like System because these will conflict with standard .NET namespaces and require resolution using the global::namespace prefix. Fallere antiquam thyrso visceribus Si mandate videt Lorem markdownum perspice caelestia orsa tamen rorant titulum Amycus parens deplangitur fuit est ; duxit cura est. Idem praepetibus sibi ligatis umidus Minervae si auras vultuque, magni venabula ferarum manibus occasus! Note This is a note which needs your attention, but it's not super important. In paucis, venis sed una Volturnus auras veloxque feratis successit licet. Oras Nestor hoc nymphae belua. Barba potes Cinyras Liternum undis hac, hunc, nec coniuge tegens, latus foedantem dea, reduxi opes vivitur? Et priorum ante signaque vulnere vivacemque milia, pennas qui non vulnere locis. Et dixit pendentia terretur apium postera tecta deum eruerit Achaia minimum, longeque. Warning This is a warning containing some important message. Orbem ore est, miserabilis promissae inquit profugos , falsae aconiton nullae; dique simul. Eris deum cepit furoris nympha. Dies iste telae cum fidelius, mihi esse est nominat quod, Anaxareten. Venit Confremuere, inplet, tibi inspiciunt iamque maesta his suis. Caution This is a warning containing some very important message. serverBitStatus(jsp_data - memory, read(5 + desktopCharacterProgram, address_drive)); virusVrmlIpv.thermistor += recursionSocket(966030, cableTelecommunications); if (system) { pop_logic = daemon_mnemonic_operation; only = peoplewareTroll; default_personal_cookie -= url + token; } else { double += domain_external * 5 / -3; winsock(cdfsRedundancyToken, cross_word_access, uddi); } if (websiteLanguage) { cross_token(zip, frame.mbr(4)); golden.backsideOsMenu += serp; whiteRestore.videoDimmOpen += mountPlain * 15; } else { spool.irc = play_suffix; cmos += 96; artUpImpact.leafWebmasterHorse = domainBrowser; } Rogavi umeris tulisse Pictas leto vix novem nitidi mentem Phoeboque, inposuere incubat thalamo: mugitibus. Busto siquid adspexerit venerit tenentibus suo habet ardet Troes . Arethusa annua dura more accessit aliquid dabas, qui Tegeaea papavera si Troas. Vota ipsa in peremi Possent anhelatos Poena quem Nutrit super eodem Donis adhaesit requiemque petit Antaeo sustinet feram Studeat occupat viro talia truncas pectine redit crimina divum illud, precesque et Minos, quidquid gratia. Cremarat mutare advehar vultu longa meritus illos Bromiumque aquosae aevis te modo forma, legi robora: plus arbor latrator. Palluit in quanta mitte miluus; amantes hominesque imago, si Ianthe, unda. Acies in vulnere secum, forte, barba fumo solet ignibus; sanguine! if (webcamSystem.modemPointClob(3) < 14) { yobibyteReimage = simplex_readme / 4 + responsive_server; } else { big(thumbnailVirtual, data_primary_lamp); } kibibyte_protector_active += nocPackBridge + white; var firewall_socket_bus = up; module_carrier += webmail_source_hardware(us, metadata, radcab - 3) - 3; cpcPartitionLink *= sessionSoa / surface * systemHacker; Nutantem spatiis, corruat memor in sed nate, auro, ora amissa fatidicus et. Manusque amore spectabat tyranni ipsa Mimasque , et tum post parvo, dedit vires et aestus et Rhoetus! Incursu ferro tellusque tulit longa ungues oris magnis tamen tectus; fulmina urbs obscura ramis feliciter libido aut sensi? Vidi oenea puppibus amanti, pro foliis, hoc est amicitiae et! Caput favorem, inimica in spinae hoc simul stantibus pependit opesque pericula avorum paene."
  },
  "articles/standard/content4.html": {
    "href": "articles/standard/content4.html",
    "title": "C# Coding Standards | CDevTeam Docs",
    "keywords": "C# Coding Standards Introduction The coding standard will be used in conjunction with customized version of StyleCop and FxCop [ TODO ] during both development and build process. This will help ensure that the standard is followed by all developers on the team in a consistent manner. \"Any fool can write code that a computer can understand. Good programmers write code that humans understand\". Martin Fowler. Refactoring: Improving the design of existing code. Purpose The aim of this section is to define a set of C# coding standards to be used by CAPS build team to guarantee maximum legibility, reliability, re-usability and homogeneity of our code. Each section is marked Mandatory or Recommended . Mandatory sections, will be enforced during code reviews as well as tools like StyleCop and FxCop , and code will not be considered complete until it is compliant. Scope This section contains general C# coding standards which can be applied to any type of application developed in C#, based on Framework Design Guidelines . It does not pretend to be a tutorial on C#. It only includes a set of limitations and recommendations focused on clarifying the development. Tools Resharper is a great 3rd party code cleanup and style tool. StyleCop analyzes C# srouce code to enforce a set of style and consistency rules and has been integrated into many 3rd party development tools such as Resharper. FxCop is an application that analyzes managed code assemblies (code that targets the .NET Framework common language runtime) and reports information about the assemblies, such as possible design, localization, performance, and security improvements. C# Stylizer does many of the style rules automatically Highlights of Coding Standards This section is not intended to give a summary of all the coding standards that enabled by our customized StyleCop, but to give a highlight of some rules one will possibly meet in daily coding life. It also provides some recommended however not mandatory(which means not enabled in StyleCop) coding standards. File Layout (Recommended) Only one public class is allowed per file. The file name is derived from the class name. Class : Observer Filename: Observer.cs Class Definition Order (Mandatory) The class definition contains class members in the following order, from less restricted scope (public) to more restrictive (private): Nested types, e.g. classes, enum, struct, etc. Field members, e.g. member variables, const, etc. Member functions Constructors Finalizer (Do not use unless absolutely necessary) Methods (Properties, Events, Operations, Overridables, Static) Private nested types Naming (Mandatory) DO use PascalCasing for all public member, type, and namespace names consisting of multiple words. PropertyDescriptor HtmlTag IOStream NOTE : A special case is made for two-letter acronyms in which both letters are capitalized, e.g. IOStream DO use camelCasing for parameter names. propertyDescriptor htmlTag ioStream DO start with underscore for private fields private readonly Guid _userId = Guid.NewGuid(); DO start static readonly fields, constants with capitalized case private static readonly IEntityAccessor EntityAccessor = null; private const string MetadataName = \"MetadataName\"; DO NOT capitalize each word in so-called closed-form compound words . DO have \"Async\" explicitly in the Async method name to notice people how to use it properly Formatting (Mandatory) DO use spaces over tabs, and always show all spaces/tabs in IDE Tips Visual Studio > TOOLS > Options > Text Editor > C# > Tabs > Insert spaces (Tab size: 4) Visual Studio > Edit > Advanced > View White Space DO add using inside namespace declaration namespace Microsoft.Content.Build.BuildWorker.UnitTest { using System; } DO add a space when: for (var i = 0; i < 1; i++) if (a == b) Cross-platform coding Our code should supports multiple operating systems. Don't assume we only run (and develop) on Windows. Code should be sensitvie to the differences between OS's. Here are some specifics to consider. DO use Enviroment.NewLine instead of hard-coding the line break instead of \\r\\n , as Windows uses \\r\\n and OSX/Linux uses \\n . Note Be aware that thes line-endings may cause problems in code when using @\"\" text blocks with line breaks. DO Use Path.Combine() or Path.DirectorySeparatorChar to separate directories. If this is not possible (such as in scripting), use a forward slash / . Windows is more forgiving than Linux in this regard. Unit tests and functional tests Assembly naming The unit tests for the Microsoft.Foo assembly live in the Microsoft.Foo.Tests assembly. The functional tests for the Microsoft.Foo assmebly live in the Microsoft.Foo.FunctionalTests assmebly. In general there should be exactly one unit test assebmly for each product runtime assembly. In general there should be one functional test assembly per repo. Exceptions can be made for both. Unit test class naming Test class names end with Test and live in the same namespace as the class being tested. For example, the unit tests for the Microsoft.Foo.Boo class would be in a Microsoft.Foo.Boo class in the test assembly. Unit test method naming Unit test method names must be descriptive about what is being tested, under what conditions, and what the expectations are . Pascal casing and underscores can be used to improve readability. The following test names are correct: PublicApiArgumentsShouldHaveNotNullAnnotation Public_api_arguments_should_have_not_null_annotation The following test names are incorrect: Test1 Constructor FormatString GetData Unit test structure The contents of every unit test should be split into three distinct stages, optionally separated by these comments: // Arrange // Act // Assert The crucial thing here is the Act stage is exactly one statement. That one statement is nothing more than a call to the one method that you are trying to test. keeping that one statement as simple as possible is also very important. For example, this is not ideal: int result = myObj.CallSomeMethod(GetComplexParam1(), GetComplexParam2(), GetComplexParam3()); This style is not recomended because way too many things can go wrong in this one statement. All the GetComplexParamN() calls can throw for a variety of reasons unrelated to the test itself. It is thus unclear to someone running into a problem why the failure occured. The ideal pattern is to move the complex parameter building into the `Arrange section: // Arrange P1 p1 = GetComplexParam1(); P2 p2 = GetComplexParam2(); P3 p3 = GetComplexParam3(); // Act int result = myObj.CallSomeMethod(p1, p2, p3); // Assert Assert.AreEqual(1234, result); Now the only reason the line with CallSomeMethod() can fail is if the method itself blew up. Testing exception messages In general testing the specific exception message in a unit test is important. This ensures that the exact desired exception is what is being tested rather than a different exception of the same type. In order to verify the exact exception it is important to verify the message. var ex = Assert.Throws<InvalidOperationException>( () => fruitBasket.GetBananaById(1234)); Assert.Equal( \"1234\", ex.Message); Use xUnit.net's plethora of built-in assertions xUnit.net includes many kinds of assertions – please use the most appropriate one for your test. This will make the tests a lot more readable and also allow the test runner report the best possible errors (whether it's local or the CI machine). For example, these are bad: Assert.Equal(true, someBool); Assert.True(\"abc123\" == someString); Assert.True(list1.Length == list2.Length); for (int i = 0; i < list1.Length; i++) { Assert.True( String.Equals list1[i], list2[i], StringComparison.OrdinalIgnoreCase)); } These are good: Assert.True(someBool); Assert.Equal(\"abc123\", someString); // built-in collection assertions! Assert.Equal(list1, list2, StringComparer.OrdinalIgnoreCase); Parallel tests By default all unit test assemblies should run in parallel mode, which is the default. Unit tests shouldn't depend on any shared state, and so should generally be runnable in parallel. If the tests fail in parallel, the first thing to do is to figure out why; do not just disable parallel tests! For functional tests it is reasonable to disable parallel tests."
  },
  "articles/standard/front-end/constants.html": {
    "href": "articles/standard/front-end/constants.html",
    "title": "Constants | CDevTeam Docs",
    "keywords": "Constants In JavaScript, the Object.freeze() method freezes an object. A frozen object can no longer be changed. <!--- examples --> const numbers = { one: 1, two: 2, three: 3 }; Object.freeze(numbers); <!-- Or directly assigned --> const numbers = Object.freeze({ one: 1, two: 2, three: 3 }); Pros & Cons Pros Frozen objects also can no longer be changed; preventing new properties frm being added to it, existing properties from being removed, prevent changing the enumerability, configurability, or writability of existing properties, and prevents the values of existing properties from being changed. Freezing an object also prevents its prototype from being changed. Freeze method returns the same object that was passed in. Cons Frozen objects with nested properties are not actually frozen. Child object's properties are mutable if the child object is not frozen as well. Our Project Structure In our main project, constants are stored in the following path src/utils/constants . Each constant structure is placed in its corresponding folder. Usage <!--- define and export frozen object in its own file --> const StudentStatuses = Object.freeze({ PreRegistro: 'Pre-Registro', Registro: 'Registro', Evaluado: 'Evaluado', Servido: 'Servido', NoElegible: 'No Elegible', Egreso: 'Egreso', Disponible: 'Disponible', Inactivo: 'Inactivo', Elegible: 'Elegible' }); export default StudentStatuses; <!-- import in file where it is going to be used --> import StudentStatuses from '@/utils/constants/reg/StudentStatuses'; References The following references were used in the creation of this documentation: JavaScript Constants https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const Object Freeze https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze"
  },
  "articles/standard/front-end/controlPrefixes.html": {
    "href": "articles/standard/front-end/controlPrefixes.html",
    "title": "Table of Standard Control Prefixes | CDevTeam Docs",
    "keywords": "Table of Standard Control Prefixes The following table is a list of the common types of controls you will encounter together with their prefixes: Prefix Control btn Button cb CheckBox cbl CheckBoxList ddl DropDownList fu FileUpload hf HiddenField hl HyperLink img Image ibtn ImageButton lbl Label lbtn LinkButton lb ListBox lit Literal mvw MultiView pnl Panel ph PlaceHolder rb RadioButton rbl RadioButtonList txt TextBox vw View wzd Wizard lvw ListView gvw GridView fvw FormView rpt Repeater ods ObjectDataSource valreq RequiredFieldValidator valrng RangeValidator valcom CompareValidator valrex RegularExpressionValidator valcus CustomValidator valsum ValidationSummary sm ScriptManager udp UpdatePanel up UpdateProgress"
  },
  "articles/standard/front-end/sass.html": {
    "href": "articles/standard/front-end/sass.html",
    "title": "Sass | CDevTeam Docs",
    "keywords": "Sass Sass is a stylesheet language that’s compiled to CSS. It allows you to use variables, nested rules, mixins, functions, and more, all with a fully CSS-compatible syntax. Sass helps keep large stylesheets well-organized and makes it easy to share design within and across projects. Syntax The SCSS syntax uses the file extension .scss . With a few small exceptions, it’s a superset of CSS, which means essentially all valid CSS is valid SCSS as well. Because of its similarity to CSS, it’s the easiest syntax to get used to and the most popular. @mixin generateColorBorder($name, $color){ .text-border__bottom--#{$name} { color: $color !important; border-bottom-color: $color !important; } } .data-name, .data-label{ @extend .font-14; @extend .color-secondary-6; } .data{ @extend .font-16; @extend .color-black; font-weight: normal; } Structure Just like CSS, most Sass stylesheets are mainly made up of style rules that contain property declarations. But Sass stylesheets have many more features that can exist alongside these. Statements Universal Statements These types of statements can be used anywhere in a Sass stylesheet: Variable declarations, like $var: value . Flow control at-rules, like _@if_ and _@each_. The _@error_, _@warn_, and _@debug_ rules. CSS Statements These statements produce CSS. They can be used anywhere except within a @function: Style rules, like h1 { /* ... */ } . CSS at-rules, like _@media_ and _@font-face_. Mixin uses using _@include_. The _@at-root_ rule. Top-Level Statements These statements can only be used at the top level of a stylesheet, or nested within a CSS statement at the top level: Module loads, using _@use_. Imports, using _@import_. Mixin definitions using _@mixin_. Function definitions using _@function_. Our Project In our project scss syntax is being used. So, our sass files are .scss extentions. This files are store in src/assets/scss in the folder where they should belong. Import @import \"./colors\"; @import \"./layouts\"; @import \"./fonts\"; @import \"./backgrounds\"; @import \"./borders\"; References The following references were used in the creation of this documentation: Sass Documentation https://sass-lang.com/documentation Preprocesor Guide https://www.creativebloq.com/web-design/what-is-sass-111517618"
  },
  "articles/standard/intro.html": {
    "href": "articles/standard/intro.html",
    "title": "Goals | CDevTeam Docs",
    "keywords": "Goals The intent of this document is not to codify current practice at DevTeam as it stands at the time of writing. Instead, this guide has the following aims: To maximize readability and maintainability by prescribing a unified style. To maximize efficiency with logical, easy-to-understand and justifiable rules that balance code safety with ease-of-use. To maximize the usefulness of code-completion tools and accommodate IDE- or framework generated code. To prevent errors and bugs (especially hard-to-find ones) by minimizing complexity and applying proven design principles. To improve performance and reliability with a list of best practices. Wherever possible, however, the guidelines include a specific justification for each design choice. Unjustified guidelines must be either justified or removed . Scope This handbook mixes recommendations for programming with .NET, MVC, AngularJS, VUE Js. It includes rules for document layout (like whitespace and element placement) as well as design guidelines for elements and best practices for their use. It also assumes that you are using Microsoft Visual Studio 2017 or newer. This guide is a work-in-progress and covers only those issues that DevTeam has encountered and codifies only that which DevTeam has put into practice and with which DevTeam has experience. Therefore, some elements of style and design as well as some implicit best practices are probably not yet documented. Speak up if you think there is something missing. Fixing Problems in the Guide Unless otherwise noted, these guidelines are not ** optional , nor are they up to interpretation**. If a guideline is not sufficiently clear, recommend a clearer formulation. If you don't like a guideline, try to get it changed or removed, but don't just ignore it. Fixing Problems in Code If code is non-conforming, it should be fixed at the earliest opportunity. If the error is small and localized, you should fix it with the next check-in (noting during the code review that the change was purely stylistic and unrelated to other bug fixes). If the error is larger and/or involves renaming or moving files, you should check the change in separately in order to avoid confusion. If the problem takes too long to repair quickly, you should create an issue in the Team Foundation Server to address the problem at a later time. When Does this Guide Apply It is the intention that all code written for or by DevTeam adheres to this standard. However, there are some cases where it is impractical or impossible to apply these conventions. This document applies to all code except the following: Code changes made to existing systems not written to this standard In general, it is a good idea to make your changes conform to the surrounding code style wherever possible. You should choose to adopt this standard for major additions to existing systems or when you are adding code that you think will become part of the DevTeam code library. Code written for customers that require that their standards should be adopted DevTeam may, from time to time work with customers that have their own coding standards. Most coding standards applicable to a Microsoft development language derive at least some of their content from a Microsoft white paper that documented a set of suggested naming standards. For this reason, many coding standards are broadly compatible with each other. This document goes a little further than most in some areas; however, it is likely that these extensions will not conflict with most other coding standards. We must be absolutely clear on this point: if there is a conflict, the customer's coding standards are to apply - always."
  },
  "articles/strategies/branching.html": {
    "href": "articles/strategies/branching.html",
    "title": "Gitflow Workflow | CDevTeam Docs",
    "keywords": "Gitflow Workflow The Gitflow Workflow defines a strict branching model designed around the project release. This provides a robust framework for managing larger projects. Gitflow is ideally suited for projects that have a scheduled release cycle. Getting Started Gitflow is really just an abstract idea of a Git workflow. This means it dictates what kind of branches to set up and how to merge them together. We will touch on the purposes of the branches below. After installing git-flow you can use it in your project by executing git flow init. Git-flow is a wrapper around Git. The git flow init command is an extension of the default git init command and doesn't change anything in your repository other than creating branches for you. How it works Develop and Master Branches Instead of a single master branch, this workflow uses two branches to record the history of the project. The master branch stores the official release history, and the develop branch serves as an integration branch for features. It's also convenient to tag all commits in the master branch with a version number. The first step is to complement the default master with a develop branch. A simple way to do this is for one developer to create an empty develop branch locally and push it to the server: > git branch develop > git push -u origin develop This branch will contain the complete history of the project, whereas master will contain an abridged version. Other developers should now clone the central repository and create a tracking branch for develop. When using the git-flow extension library, executing git flow init on an existing repo will create the develop branch: > $ git flow init > Initialized empty Git repository in ~/project/.git/ > No branches exist yet. Base branches must be created now. > Branch name for production releases: [master] > Branch name for \"next release\" development: [develop] > How to name your supporting branch prefixes? > Feature branches? [feature/] > Release branches? [release/] > Hotfix branches? [hotfix/] > Support branches? [support/] > Version tag prefix? [] > $ git branch > * develop > master Feature Branches Each new feature should reside in its own branch, which can be pushed to the central repository for backup/collaboration. But, instead of branching off of master, feature branches use develop as their parent branch. When a feature is complete, it gets merged back into develop. Features should never interact directly with master. Note that feature branches combined with the develop branch is, for all intents and purposes, the Feature Branch Workflow. But, the Gitflow Workflow doesn’t stop there. Feature branches are generally created off to the latest develop branch. Creating a feature branch Without the git-flow extensions: > git checkout develop > git checkout -b feature_branch When using the git-flow extension: > git flow feature start feature_branch Continue your work and use Git like you normally would. Finishing a feature branch When you’re done with the development work on the feature, the next step is to merge the feature_branch into develop. Without the git-flow extensions: > git checkout develop > git merge feature_branch Using the git-flow extensions: > git flow feature finish feature_branch Once develop has acquired enough features for a release (or a predetermined release date is approaching), you fork a release branch off of develop. Creating this branch starts the next release cycle, so no new features can be added after this point—only bug fixes, documentation generation, and other release-oriented tasks should go in this branch. Once it's ready to ship, the release branch gets merged into master and tagged with a version number. In addition, it should be merged back into develop, which may have progressed since the release was initiated. Using a dedicated branch to prepare releases makes it possible for one team to polish the current release while another team continues working on features for the next release. It also creates well-defined phases of development (e.g., it's easy to say, “This week we're preparing for version 4.0,” and to actually see it in the structure of the repository). Making release branches is another straightforward branching operation. Like feature branches, release branches are based on the develop branch. A new release branch can be created using the following methods. Without the git-flow extensions: > git checkout develop > git checkout -b release/0.1.0 When using the git-flow extensions: > $ git flow release start 0.1.0 > Switched to a new branch 'release/0.1.0' Once the release is ready to ship, it will get merged it into master and develop, then the release branch will be deleted. It’s important to merge back into develop because critical updates may have been added to the release branch and they need to be accessible to new features. If your organization stresses code review, this would be an ideal place for a pull request. To finish a release branch, use the following methods: Without the git-flow extensions: > git checkout master > git merge release/0.1.0 Or with the git-flow extension: > git flow release finish '0.1.0' Hotfix Branches Maintenance or “hotfix” branches are used to quickly patch production releases. Hotfix branches are a lot like release branches and feature branches except they're based on master instead of develop. This is the only branch that should fork directly off of master. As soon as the fix is complete, it should be merged into both master and develop (or the current release branch), and master should be tagged with an updated version number. Having a dedicated line of development for bug fixes lets your team address issues without interrupting the rest of the workflow or waiting for the next release cycle. You can think of maintenance branches as ad hoc release branches that work directly with master. A hotfix branch can be created using the following methods: Without the git-flow extensions: > git checkout master > git checkout -b hotfix_branch When using the git-flow extensions: > git flow hotfix start hotfix_branch Similar to finishing a release branch, a hotfix branch gets merged into both master and develop. > git checkout master > git merge hotfix_branch > git checkout develop > git merge hotfix_branch > git branch -D hotfix_branch > $ git flow hotfix finish hotfix_branch Example A complete example demonstrating a Feature Branch Flow is as follows. Assuming we have a repo setup with a master branch. > git checkout master > git checkout -b develop > git checkout -b feature_branch > > # work happens on feature branch > > git checkout develop > git merge feature_branch > git checkout master > git merge develop > git branch -d feature_branch In addition to the feature and release flow, a hotfix example is as follows: > git checkout master > git checkout -b hotfix_branch > > # work is done commits are added to the hotfix_branch > > git checkout develop > git merge hotfix_branch > git checkout master > git merge hotfix_branch Source https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow"
  },
  "articles/strategies/components/verdaccio.html": {
    "href": "articles/strategies/components/verdaccio.html",
    "title": "Verdaccio | CDevTeam Docs",
    "keywords": "Verdaccio Verdaccio is a simple, zero-config-required local private npm registry. Verdaccio to use all benefits of npm package system in your company without sending all code to the public, and use your private packages just as easy as public ones. Packages http://tfstools.cdevteam.com:4873/ Installing > $ npm i <package-name>; Usage After package is installed in your project, just need to import it as if it was a local component. > import ActionButton from 'ActionButton'; Project Getting Started Clone > import ActionButton from 'ActionButton'; npm install > npm install; Run After packages have been installed you can run project locally > npm run storybook; When project runs, a Storybook page is opened where you can test UI components."
  },
  "articles/strategies/cssmanagement.html": {
    "href": "articles/strategies/cssmanagement.html",
    "title": "| CDevTeam Docs",
    "keywords": ""
  },
  "articles/strategies/intro.html": {
    "href": "articles/strategies/intro.html",
    "title": "| CDevTeam Docs",
    "keywords": "..."
  },
  "articles/strategies/pipelines.html": {
    "href": "articles/strategies/pipelines.html",
    "title": "CI/CD Pipelines | CDevTeam Docs",
    "keywords": "CI/CD Pipelines Development Release Production HotFix"
  },
  "articles/unitTesting/back-end/backEnd.html": {
    "href": "articles/unitTesting/back-end/backEnd.html",
    "title": "Back Info | CDevTeam Docs",
    "keywords": "Back Info sdfsd"
  },
  "articles/unitTesting/front-end/frontEnd.html": {
    "href": "articles/unitTesting/front-end/frontEnd.html",
    "title": "front info | CDevTeam Docs",
    "keywords": "front info asdasd"
  },
  "articles/unitTesting/intro.html": {
    "href": "articles/unitTesting/intro.html",
    "title": "| CDevTeam Docs",
    "keywords": "Falta intro Unit Testing"
  },
  "CHANGELOG.html": {
    "href": "CHANGELOG.html",
    "title": "Changelog | CDevTeam Docs",
    "keywords": "Changelog Version 0.4.0 - May 19th 2020 Usability improvements and minor style changes in textboxes. Version 0.3.1 - January 13th 2020 Minor update in styles and shadows. Version 0.3.0 - December 2nd 2019 Added easy customization of header and link colors. Version 0.2.0 - February 1st 2019 Added material theme for the note|warning|caution blockquotes. Updated syntax highlight styles. Version 0.1.0 - January 31st 2019 First release of the DocFX Material theme"
  },
  "index.html": {
    "href": "index.html",
    "title": "| CDevTeam Docs",
    "keywords": ""
  }
}